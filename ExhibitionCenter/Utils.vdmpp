class Utils
types
	public Date :: 	year : nat
									month: nat
									day : nat
				inv d == d.month <= 12 and d.day <= DaysOfMonth(d.year, d.month);
	public String = seq of char;
values
functions
	public DaysOfMonth: nat * nat -> nat 
	DaysOfMonth(y, m) ==
				if (m = 2)
				then
						(if (isLeapYear(y))
						then 29
						else 28)
        else (31 - (m - 1) mod 7 mod 2)
	pre y > 0 and m > 0 and m < 13
	post (m = 2 and isLeapYear(y) and RESULT = 29) or
		(m = 2 and not isLeapYear(y) and RESULT = 28) or
		(RESULT = (31 - (m - 1) mod 7 mod 2)); 
	
	public before: Date * Date -> bool 
	before(b, a) ==
		b.year < a.year or
		(b.year = a.year and b.month < a.month) or
		(b.year = a.year and b.month = a.month and b.day < a.day)
	pre true
	post b.year < a.year or
		(b.year = a.year and b.month < a.month) or
		(b.year = a.year and b.month = a.month and b.day < a.day);

	public isLeapYear: nat -> bool
	isLeapYear(y) == 
		y mod 4 = 0 and y mod 100 <> 0 or y mod 400 = 0
	pre y > 0
	post y mod 4 = 0 and y mod 100 <> 0 or y mod 400 = 0;

-- Curried Function
-- Received function can return a boolean or an element of the same map value type
-- Apply a generic function to all map elements and change them (when function returns an element) or
-- filter the ones that verify the condition (when function returns a boolen)
	public fMap[@keyType, @returnType, @valueType]: (@valueType -> @returnType) -> seq of @keyType * (map @keyType to @valueType) -> (map @keyType to @valueType)
	fMap (f)(keys, m) ==
	if keys = [] then {|->}
	else def key = m(hd keys) in (
		def res = f(m(key)) in (
			if(is_bool(res)) then (
				if(res) then {key|->m(key)} ++ (fMap[@keyType, @returnType, @valueType] (f)(tl keys, m))
				else fMap[@keyType, @returnType, @valueType] (f)(tl keys, m)
			)
			elseif(is_(res, @valueType)) then {key|->res} ++ (fMap[@keyType, @returnType, @valueType] (f)(tl keys, m))
			else {|->} -- case of error. ask teacher how to use trap error with exit in (...)
		)
	)
	pre elems keys = dom m
	post dom RESULT subset elems keys
	measure mfMap;

-- fMap measure function
	public mfMap[@keyType, @returnType, @valueType]: (@valueType -> @returnType) * seq of @keyType * (map @keyType to @valueType) -> nat
	mfMap (-, keys, -) == len keys;
	
--Turns set into seq
	public setTOseq[@elem]: set of @elem -> seq of @elem
	setTOseq(tmpSet) == (
		[x | x in set tmpSet]
	)
	post elems RESULT subset tmpSet
	measure msetTOseq;
	
-- setTOseq measure function
	public msetTOseq[@elem]: set of @elem -> nat
	msetTOseq(tmpSet) == card tmpSet;

end Utils