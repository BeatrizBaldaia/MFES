class Utils
types
	public Date :: 	year : nat
									month: nat
									day : nat
				inv d == d.month <= 12 and d.day <= DaysOfMonth(d.year, d.month);
	public String = seq of char;
values
functions
	public DaysOfMonth: nat * nat -> nat 
	DaysOfMonth(y, m) == y*m -- TODO: implementar
	pre y > 0 and m > 0 and m < 13;
	-- TODO: post
	
	public before: Date * Date -> bool 
	before(b, a) == true; -- TODO: implementar
	-- TODO: pre post

-- Curried Function
-- Received function can return a boolean or an element of the same map value type
-- Apply a generic function to all map elements and change them (when function returns an element) or
-- filter the ones that verify the condition (when function returns a boolen)
	public fMap[@keyType, @returnType, @valueType]: (@valueType -> @returnType) -> seq of @keyType * (map @keyType to @valueType) -> (map @keyType to @valueType)
	fMap (f)(keys, m) ==
	if keys = [] then {|->}
	else def key = m(hd keys) in (
		def res = f(m(key)) in (
			if(is_bool(res)) then (
				if(res) then {key|->m(key)} ++ (fMap[@keyType, @returnType, @valueType] (f)(tl keys, m))
				else fMap[@keyType, @returnType, @valueType] (f)(tl keys, m)
			)
			elseif(is_(res, @valueType)) then {key|->res} ++ (fMap[@keyType, @returnType, @valueType] (f)(tl keys, m))
			else {|->} -- case of error. ask teacher how to use trap error with exit in (...)
		)
	)
	pre elems keys = dom m
	post dom RESULT subset elems keys
	measure mfMap;

-- fMap measure function
	public mfMap[@keyType, @returnType, @valueType]: (@valueType -> @returnType) * seq of @keyType * (map @keyType to @valueType) -> nat
	mfMap (-, keys, -) == len keys;
	
--Turns set into seq
	public setTOseq[@elem]: set of @elem -> seq of @elem
	setTOseq(tmpSet) == (
		[x | x in set tmpSet]
	)
	post elems RESULT subset tmpSet
	measure msetTOseq;
	
-- setTOseq measure function
	public msetTOseq[@elem]: set of @elem -> nat
	msetTOseq(tmpSet) == card tmpSet;

end Utils