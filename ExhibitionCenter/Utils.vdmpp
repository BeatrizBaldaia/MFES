class Utils
types
	public Date :: 	year : nat
									month: nat
									day : nat
				inv d == d.month <= 12 and d.day <= DaysOfMonth(d.year, d.month);
	public String :: seq of char;
values
functions
	public DaysOfMonth: nat * nat -> nat 
	DaysOfMonth(y, m) == y*m -- TODO: implementar
	pre y > 0 and m > 0 and m < 13;
	-- TODO: post
	
	public before: Date * Date -> bool 
	before(b, a) == true; -- TODO: implementar
	-- TODO: pre post

-- Apply a generic function to a map and returns the keys of the ones who verify the function
	public fMap[@keyType, @returnType, @valueType]: (@valueType -> @returnType) -> seq of @keyType * (map @keyType to @valueType) -> (map @keyType to @valueType)
	fMap (f)(keys, m) ==
	if keys = [] then {|->}
	else def key = m(hd keys) in (
		def res = f(m(key)) in (
			if(is_bool(res)) then (
				if(res) then {key|->m(key)} ++ (fMap[@keyType, @returnType, @valueType] (f)(tl keys, m))
				else fMap[@keyType, @returnType, @valueType] (f)(tl keys, m)
			)
			elseif(is_(res, @valueType)) then {key|->res} ++ (fMap[@keyType, @returnType, @valueType] (f)(tl keys, m))
			else {|->} -- case of error. ask teacher how to use trap error with exit in (...)
		)
	)
	pre elems keys = dom m
	post dom RESULT subset elems keys
	measure mfMap;

-- fMap measure function
	public mfMap[@keyType, @returnType, @valueType]: (@valueType -> @returnType) * seq of @keyType * (map @keyType to @valueType) -> nat
	mfMap (-, keys, -) == len keys;
	


end Utils